# 面试题

## vue

* `Vue` 响应式原理
* `nextTick`实现原理
* `watch`和`computed`的区别的实现原理
* 为什么采用异步渲染
* `Vue`的`data`属性为什么是一个函数
* `Vue`声明周期
* 组件之间的通信
* `keep-alive`
* `proxy`相比`defineProperty`的优势
* 双向数据绑定实现原理



## javascript

* `JavaScript`闭包

  > 1. 什么是闭包
  >
  >    `JavaScript`闭包是指有权访问另一个函数作用域中的变量的函数。
  >
  > 2. 闭包的作用：
  >     1. 闭包可以读取函数内部声明的变量。
  >     2. 让函数内部变量的值始终保持在内存中。
  > 3. 闭包注意事项
  >    1. 闭包使得函数中的变量一直贮存在内存中，大量使用闭包，会导致网页性能问题。在IE中会导致内存泄漏。
  >
  > 

 

* `JavaScript`有几种继承方式

  > 1. 组合继承
  >
  >    在子类的构造函数中， 使用`call`或`apply` 调用父类的构造函数实现实例属性和方法的继承，然后， 实例化父类，将实例化对象赋值给 子类的`prototype`，同时需要修改子类`prototype`中的`constructor`为子类的构造函数。  实现原型属性和方法的继承。这种继承方式因为是直接将父类实例化的对象直接赋值给子类的`prototype`。 会导致子类的`prototype`中不仅有父类`prototype`中的属性或方法还会有父类实例化对象的示例属性或方法。
  >
  > 2. 使用`create`实现
  >
  >    `ES5`的`Object`对象提供一个`create`方法， 他在内部声明一个构造函数，将改构造函数的原型赋值为`create`方法的参数，最后实例化这个构造函数并返回。
  >
  >    **可以利用这个特性来实现继承， 实现原理和组合继承一样，但是他借用了一个中间的一个空构造函数，这个构造函数没有任何实例属性和方法，所以相对于组合继承不会出现有多余的实例属性或方法**
  >
  > 3. 使用`ES6` 的 `extends` 来实现

* `new`一个类的过程

  > 1. 创建一个空的`JavaScript` 对象`{}`
  > 2. 将创建的对象作为其调用上下文，使用`this`来引用这个对象
  > 3. 将创建的对象的 `__proto__`指向构造函数的`prototype`
  > 4. 如果构造函数返回的是一个对象就返回对象，否则返回`this`

* `this`的理解

  > `JavaScript`的`this`是在运行时基于函数的执行环境决定的。一般分为以下几种
  >
  > * 全局环境
  >
  >   全局环境`this`指向 全局对象，浏览器中 全局对象为`window`
  >
  > * 普通函数调
  >
  >   普通函数调用在非严格模式`this`和在全局环境中一样，在严格模式下 `this`为`undefined`
  >
  > * 构造函数
  >
  >   构造函数中的`this`将指向正在构造的新对象，即实例化后的对象
  >
  > * 箭头函数
  >
  >   如果箭头函数被非箭头函数包裹，则箭头函数中的`this`为外层非箭头函数的`this`
  >
  > * 使用`call`、`apply`、`bind`
  >
  >   使用`call`、`apply`、`bind`方式调用 `this`的值分为以下几种情况
  >
  >   * 如果是一个对象，`this`为这个对象， 
  >   * 如果传入的是 `null`或 `undefined`，`this`将指向`全局对象`
  >   * 如果传入的是一个原始值，会使用对应的构造函数将其转换为对象，`this`将指向这个对象

* 数组哪些方法会改变原数组

* 数组的`splice`和`slice`的区别

* `call`、`apply`、`bind`的区别

* 作用域和作用域链

* 事件捕获和事件冒泡

* 事件委托

* 事件对象中 `target`和`currentTarget`

  > `target`是事件触发的元素，`currentTarget`事件绑定的元素

* 如何获取函数的实参和形参的个数

  > 使用函数的`length` 获取形参的个数， 使用`arguments`或`ES6`的`...`操作符获取实参个数

* 节流和防抖

* 事件循环

* 跨域

  > 

* `promise`

* 简单请求和复杂请求

* 箭头函数和普通函数的区别

  > 1. 箭头函数没有`this`,`arguments`,`super`,`new.target`的绑定
  > 2. 箭头函数不能用作构造函数， 因为箭头函数内部没有`[[Construct]]`方法。
  > 3. 箭头函数没有原型， 因为箭头函数不能用作构造函数，所以没有构建原型的需求。
  > 4. 不可以改变`this`的绑定,如果箭头函数被外层非箭头函数包裹，`this`为外层函数的`this`，否则为全局对象
  > 5. 不支持`arguments`,如果箭头函数被外层非箭头函数包裹，`arguments`为外层函数的`arguments`，否则会报错找不到`arguments`，可以通过显示命名参数或使用不定参数形式访问
  > 6. 不支持重复的命名参数，普通函数在非严格模式是可以有的

* `for...of`和`for`以及`for...in`的区别

  > 1. `for...in`循环可以对对象或数组进行循环， 循环的每一项是对象的`key`, 数组中的`key`为数组索引，对象循环输出的`key`的顺序不可预测， 对对象原型链中可以枚举的属性也会遍历出来。如果不想输出原型链中的可枚举属性，可以使用`hasOwnProperty`方法进行判断。
  > 2. `for`循环可以对`数组`或**`类数组`** 
  > 3. `for...of` 可以遍历具有迭代器方法的任何对象

## css/less/sass

* `flex`布局
* `grid`布局
* `BFC`
* 层叠上下文
* 选择符优先级
* 盒模型
* `transition`和`animation`的区别
* 垂直水平居中实现方式
* `padding`和`margin` 的百分比是相对于什么的

## node/express

* 如何处理高并发

## mongodb

* 数据类型
* 如何优化海量数据中分页查找时性能问题
* 如何做索引
* 什么是分片和复制集
* 基于地理位置做搜索
* 聚合

## http

* `http`常见状态码和含义
* `http2.0`有哪些新功能
* `GET` 和`POST`的区别
* `TCP`三次握手和四次挥手
* 缓存

## TypeScript



## 算法

* 排序算法



## 版本控制管理

* `git`如何放弃当前`commit`

## 其他

* 性能优化
* 浏览器渲染页面过程