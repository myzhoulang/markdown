# 面试题

## vue

* `Vue` 响应式原理

* `nextTick`实现原理

  > `vue`更新`dom`是异步操作，数据改变组件不会立即渲染。`nextTick`可以访问到数据改变，浏览器渲染之后的最新`dom`。`nextTick`将需要执行的回调，`push`到`callbacks`数组，然后定义执行这个数组中所有回调的函数，利用`Promise`或`setTimeout`将这个函数放入微任务或宏任务中，使得这些回调在下一次事件循环中执行，从而获取到最新的`dom`。

* `watch`和`computed`的区别的实现原理

* 为什么采用异步渲染

  > 当一个响应式属性同步修改多次，每一次属性修改都会触发`watcher`，每一触发都会执行复杂的计算和`dom`操作。`vue`在观察到数据变化时，将开启一个队列，并且缓冲同一事件循环中所有数据的改变，如果同一个`watcher`被多次触发，只会被推入队列一次，然后在下一次事件循环中执行。

* `Vue`组件的`data`属性为什么是一个函数

  > 组件可能被用来创建多个实例，如果`data`是一个纯对象，多个实例将共享一个数据对象，某一个实例上的数据被修改，会影响到其他组件实例。如如果是一个函数， 每次创建实例都是返回一个全新的副本数据。

* `Vue`声明周期

  > 1. `beforeCreated`
  > 2. `created`
  > 3. `beforeMounted`
  > 4. `mounted`
  > 5. `beforeUpdate`
  > 6. `updated`
  > 7. `activated`( 被`keep-alive`缓存的组件被激活时)
  > 8. `deactivated`( 被`keep-alive`缓存的组件被停用时)
  > 9. `beforeDestroy`
  > 10. `destroyed`

* 组件之间的通信

  > * `props` /` $emit`
  >
  > * `ref `/ `$parent/$children`
  >
  >   `ref`如果在普通对象上使用，指向`DOM`,如果是子组件，则指向组件实例
  >
  >   `$parent` 访问父组件
  >
  >   `$children`访问子组件
  >
  > * `EventBus（$emit/$on）`
  >
  >   创建一个空的`Vue`实例,用来触发事件和监听事件
  >
  > * `provide`/`inject`
  >
  >   祖先组件通过`provide`提供一个对象，子孙组件通过`inject`注入对象上的属性
  >
  > * `vuex`

* `keep-alive`

  > `keep-alive`是一个`vue`的内置的抽象组件，自身不会渲染一个DOM元素，也不会出现在父组件链中，使用`keep-alive`包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
  >
  > `keep-alive`首先获取包裹的第一个子组件对象和组件名称，根据设置的黑白名单判断是否缓存，根据组件`ID`和`tag`生成缓存的`key`,在缓存对象中查找是否缓存过改组件，如果有就取出缓存实例，并更新该`key`在`this.keys`中的位置,便于当缓存组件超出设置的最大缓存数量时处理。 否则将该组件缓存到缓存对象中，然后检查缓存数量是否超过缓存数量最大值，如果超过就删除最早缓存且未使用的组件，最后将组件实例的`keepAlive`属性设为`true`，用于被包裹组件的不会进入`mounted`和他之前的所有钩子函数。

* `proxy`相比`defineProperty`的优势

* 双向数据绑定实现原理

* 指令的实现原理



## javascript

* `var`、`let`、`const`的区别

  > *  var
  >
  >    *  有变量提升特效
  >   *  只有全局作用域和函数作用域，无块级作用域
  >    *  可重复定义与赋值
  >    *  在给一个非声明变量赋值会隐式创建一个全局变量
  >    *  浏览器环境下，全局作用域下的变量与window下同名属性全等的
  > 
  > *  let
  >
  >    *  只在其声明的代码块或子块中有效
  >   *  存在暂时性死区（将变量提升到语句块顶部，但在块的开始到声明这一段使用这个变量会导致错误，这一段称之为暂存死区）
  >    *  不允许在相同作用域内重复声明，也不能对参数重新声明
  >    *  在全局中声明的变量与window属性不等
  > 
  > * const
  >
  >   **有上面let的特性和下面的两个自己的特性**
  >
  >   * 常量的值不能改变 (不能改变的是内存地址，复合型数据类型是可以改变的)
  >  * 常量必须在声明的时候就赋值
  
* `JavaScript`闭包

  > 1. 什么是闭包
  >
  >    `JavaScript`闭包是指有权访问另一个函数作用域中的变量的函数。
  >
  > 2. 闭包的作用：
  >     1. 闭包可以读取函数内部声明的变量。
  >     2. 让函数内部变量的值始终保持在内存中。
  > 3. 闭包注意事项
  >   
  >    1. 闭包使得函数中的变量一直贮存在内存中，大量使用闭包，会导致网页性能问题。在IE中会导致内存泄漏。
  >
  > 

 

* `JavaScript`有几种继承方式

  > 1. 组合继承
  >
  >    在子类的构造函数中， 使用`call`或`apply` 调用父类的构造函数实现实例属性和方法的继承，然后， 实例化父类，将实例化对象赋值给 子类的`prototype`，同时需要修改子类`prototype`中的`constructor`为子类的构造函数。  实现原型属性和方法的继承。这种继承方式因为是直接将父类实例化的对象直接赋值给子类的`prototype`。 会导致子类的`prototype`中不仅有父类`prototype`中的属性或方法还会有父类实例化对象的示例属性或方法。
  >
  > 2. 使用`create`实现
  >
  >    `ES5`的`Object`对象提供一个`create`方法， 他在内部声明一个构造函数，将改构造函数的原型赋值为`create`方法的参数，最后实例化这个构造函数并返回。
  >
  >    **可以利用这个特性来实现继承， 实现原理和组合继承一样，但是他借用了一个中间的一个空构造函数，这个构造函数没有任何实例属性和方法，所以相对于组合继承不会出现有多余的实例属性或方法**
  >
  > 3. 使用`ES6` 的 `extends` 来实现

* `new`一个类的过程

  > 1. 创建一个空的`JavaScript` 对象`{}`
  > 2. 将创建的对象作为其调用上下文，使用`this`来引用这个对象
  > 3. 将创建的对象的 `__proto__`指向构造函数的`prototype`
  > 4. 如果构造函数返回的是一个对象就返回对象，否则返回`this`

* `this`的理解

  > `JavaScript`的`this`是在运行时基于函数的执行环境决定的。一般分为以下几种
  >
  > * 全局环境
  >
  >   全局环境`this`指向 全局对象，浏览器中 全局对象为`window`
  >
  > * 普通函数调
  >
  >   普通函数调用在非严格模式`this`和在全局环境中一样，在严格模式下 `this`为`undefined`
  >
  > * 构造函数
  >
  >   构造函数中的`this`将指向正在构造的新对象，即实例化后的对象
  >
  > * 箭头函数
  >
  >   如果箭头函数被非箭头函数包裹，则箭头函数中的`this`为外层非箭头函数的`this`
  >
  > * 使用`call`、`apply`、`bind`
  >
  >   使用`call`、`apply`、`bind`方式调用 `this`的值分为以下几种情况
  >
  >   * 如果是一个对象，`this`为这个对象， 
  >   * 如果传入的是 `null`或 `undefined`，`this`将指向`全局对象`
  >   * 如果传入的是一个原始值，会使用对应的构造函数将其转换为对象，`this`将指向这个对象

* 数组哪些方法会改变原数组

  > `push`、`shift`、`pop`、`unshift`、`splice`、`concat`、`sort`、`fill`

* 数组的`splice`和`slice`的区别

  > 1. `slice`是浅复制一个数组中的多个元素，以数组的形式返回，原数组不会被改变，新数组的元素取决于`slice`参数的设置, 
  >
  > ​	第一个参数代表开始位置，默认从0开始，如果是负数，则从数组的倒数第几个开始，如果大于数组的长度，则返回空数组。
  >
  > ​	第二个参数结束的索引位置，默认是到数组的末尾。但不包含这个索引对应的元素，如果是负数，则从数组的倒数第几个结束，不包含索引位置的元素。如果大于数组长度，则到数组的末尾
  >
  > 2. `splice`是删除、替换现有元素、添加新元素来修改数组，并且以数组的形式返回被删除的元素。原数组会被修改。
  >
  >    第一个参数代表操作开始的位置
  >
  >    第二个参数代表需要删除数组的个数
  >
  >    第三个到第N个参数代表需要添加的数组元素
  >
  > 

* `call`、`apply`、`bind`的区别

  > 这三个函数方法都是改变`this`指向的。
  >
  > 
  >
  > 区别:
  >
  > 1. 执行函数的`call`和`apply`方法后函数就会马上执行对应的函数,无返回值，`bind`是返回一个函数，需要执行这个返回的新函数才能执行对应的函数。
  > 2. `call`和`bind`传递参数是直接传递，`apply`传递参数是传入一个参数数组

* 作用域和作用域链

  > 作用域是变量和函数可访问的区域，分为全局作用域、函数作用域、块级作用域。
  >
  > `JavaScript`在进入一个新执行环境执行时，会创建一个当前执行环境中变量和函数可以访问的所有作用域的有序集合。这个集合就是作用域链。作用域链保证了这些变量和函数的在可访问的作用域中的有序访问。作用域链的最前端永远是当前执行环境， 

* 事件捕获和事件冒泡

  > 事件冒泡是有事件最具体的元素开始接受，逐级向上传播一直到`document`。事件捕获和事件冒泡相反，它是从`document`到事件具体元素。**执行顺序是先执行事件捕获然后执行事件冒泡**

* 事件委托

  > 当一个页面注册的事件越来越多，会导致页面性能问题， 每一个处理事件函数都是一个对象，都会占用内存。事件委托可以利用**事件冒泡**机制将事件绑定到`DOM`的**父级或祖先**上，减少事件绑定对象。
  >
  > 如果我们判断的元素里面还有子元素的时候，我们点击的时候子元素，这时候`target`是子元素。这样就不会执行事件处理函数。需要使用下面的方式可以达到效果
  >
  > ```js
  > function delegate(element, eventType, selector, fn) {
  >   element.addEventListener(eventType, e => {
  >     let el = e.path.find(el => el.matches(selector))
  >     el && fn.call(el, e, el)
  >   })
  >   return element
  > }
  > ```
  >
  > 

* 事件对象中 `target`和`currentTarget`

  > `target`是事件触发的元素，`currentTarget`事件绑定的元素

* 如何获取函数的实参和形参的个数

  > 使用函数的`length` 获取形参的个数， 使用`arguments`或`ES6`的`...`操作符获取实参个数

* 节流和防抖

  > 节流是在一个单位时间内。只能有一次触发事件的回调函数被执行， 如果事件被触发多次，只有一次生效。
  >
  > 防抖是在事件被触发n秒后执行函数，如果在n秒内被在次触发，则重新计时。

* 事件循环

  > 

* 跨域

  > 1. `jsonp`
  >
  >    由于`script`标签不受同源策略的限制，客户端可以动态添加一个`script`标签，将`src`指向服务器资源地址，`src`参数带上一个回调函数的名称，然后在全局中注册这个回调函数。服务端接受并处理这个请求，将处理后的数据当做这个回调函数的参数并返回， 浏览器接受到这个脚本的返回值就会执行这个回调函数。
  >
  >    缺点： 
  >
  >    1. 请求方法只能是`GET`
  >    2. 安全性问题,`JSONP`会从其他域下加载脚本执行，会有安全隐患。
  >    3. 缺乏错误处理机制，无法检测服务器出错的原因
  >
  > 2. 服务器反向代理
  >
  >    需要代理服务器设置
  >
  > 3. `CORS`
  >
  >    需要服务器设置响应的响应头信息
  >
  > 4. `document.domain`
  >
  >    缺点：
  >
  >    1. 主域名必须要一样
  >
  > 5. `postmessage`

* `promise`

  > * Promise 中 .then 的第二参数与 .catch 有什么区别?
  >
  >   `then`中`reject`只能捕获
  >
  > * 
  >
  > 

* 简单请求和复杂请求

  > 

* 箭头函数和普通函数的区别

  > 1. 箭头函数没有`this`,`arguments`,`super`,`new.target`的绑定
  > 2. 箭头函数不能用作构造函数， 因为箭头函数内部没有`[[Construct]]`方法。
  > 3. 箭头函数没有原型， 因为箭头函数不能用作构造函数，所以没有构建原型的需求。
  > 4. 不可以改变`this`的绑定,如果箭头函数被外层非箭头函数包裹，`this`为外层函数的`this`，否则为全局对象
  > 5. 不支持`arguments`,如果箭头函数被外层非箭头函数包裹，`arguments`为外层函数的`arguments`，否则会报错找不到`arguments`，可以通过显示命名参数或使用不定参数形式访问
  > 6. 不支持重复的命名参数，普通函数在非严格模式是可以有的

* `for...of`和`for`以及`for...in`的区别

  > 1. `for...in`循环可以对对象或数组进行循环， 循环的每一项是对象的`key`, 数组中的`key`为数组索引，对象循环输出的`key`的顺序不可预测， 对对象原型链中可以枚举的属性也会遍历出来。如果不想输出原型链中的可枚举属性，可以使用`hasOwnProperty`方法进行判断。
  > 2. `for`循环可以对`数组`或**`类数组`** 
  > 3. `for...of` 可以遍历具有迭代器方法的任何对象

* 0.1 + 0.2 = 0.3 怎么处理

* 实现深拷贝

  > 1. 递归遍历实现，实现过程检测类型，还需要检测是否有循环引用，如果使用`for in`还需要注意是否是原型上的属性
  > 2. 使用`JSON.stringify`和`JSOfN.parse`，这种方式对数据格式有要求，值不能为 `undefined`、`function`类型

## css/less/sass

* `flex`布局

* `grid`布局

* `BFC`

  > `BFC`是块级格式化上下文。指当元素满足特定条件就会形成一个**单独**的盒模型渲染模式**区域**。
  >
  > 触发`BFC`的条件：根元素、`position`值不为`static`和`relative`、`float`不为`none`、`overflow`不为`visible`、`display`值为`flex`、`table-cell`、`table-caption`、`inline-block`、`inline-flex`、` flow-root`、 `grid`等
  >
  > `BFC`特点：
  >
  > 1. 一个独立的渲染区域，与外部互不影响
  > 2. 内部元素按垂直方向从上向下排列
  > 3. `margin`不会叠加

* 层叠上下文

* 选择符优先级

  > `!import > 内联 style > id > class 、属性选择器 > 标签 > *`

* 盒模型

  > 正常模式：宽度 = padding + border + content
  >
  > 怪异模式：宽度 = content 宽度
  >
  > 怎么触发怪异模式计算：`CSS3`的`box-sizing: border-box`,`doctype`的缺失在IE6,7,8中会触发怪异模式。

* `transition`和`animation`的区别

  > `transition`是在两个状态之间的过渡，`animation`可以更细粒的控制，还可以循环播放。

* 垂直水平居中实现方式

  > 1. `flex`布局
  > 2. `grid`
  > 3. `aboute`
  > 4. `line-height`和`marign: 0 auto`
  > 5. `table`

* `position`有哪些属性

  > 1. `relative`
  > 2. `absoute`
  > 3. `sticky`
  > 4. `static`
  > 5. `fixed`

* `padding`和`margin` 的百分比是相对于什么的

  > `padding`和`margin`的百分比是相对于元素自身的宽度。



* `margin`和`padding`在`block`和`inline`中的区别

  > `block`的`padding`和`margin`设置后都会产生边距。
  >
  > `inline`的`padding`和`margin`的`left`和`right`会产生边距，`top`和`bottom`不会产生边距

* `flex: 0 1 auto`是什么意思

  > `flex`是`flex-grow`、`flex-shrink`、`flex-basis`的简写
  >
  > `flex-grow`为项目的放大比例 .`0`为如果存在剩余空间，也不放大。
  >
  > `flex-shrink`为定义了项目的缩小比例。`1`如果空间不足，该项目将缩小 
  >
  > `flex-basis`为属性定义了在分配多余空间之前，项目占据的主轴空间（main size）`auto`为`item`原来的大小

## node/express

* 如何处理高并发

## mongodb

* 如何优化海量数据中分页查找时性能问题

  > 客户端发送一个有序、唯一、可以比较的一个字段，这个字段的值是每一次分页返回的最后一条数据的字段值。通过这个字段减少分页的搜索数据量。

* 如何做索引

* 什么是分片和复制集

  > 分片是将数据拆分，将其分散存在到不同的机子上。分片可以存储更多的数据，处理更大的负载。
  >
  > 复制集是自动故障恢复的主从集群。主节点负责写入数据，从节点自动同步主节点的数据，并提供查询

* 基于地理位置做搜索

* 聚合

## webpack

* `loader`

  > `webpack`把所有资源当成模块处理，这些资源最终需要转换成不同类型的资源。`loader`本质上就是一个函数，对这些模块对这些模块进行转换，最后返回转换后的结果。如：`TypeScript`转换成`JavaScript`,`less`转换成`css`等.

* `plugin`

  > `plugin`用于解决`loader`无法实现的其他事，`plugin`可以扩展`webpack`的功能。可以监听在`webpack`运行的声明周期中发出的各种事件，然后通过`webpack`提供的`api`改变输出结果。

* `webpack`构建流程

  > 1. 启动构建，读取合并配置参数



* `webpack`构建速度优化

  > `webpack`优化首先需要分析是哪一块比较耗时，可以使用`speed-measure-webpack-plugin`插件，来分析整个打包过程的总耗时和每一个插件和`loader`的耗时。
  >
  > 解决方案：
  >
  > 1. 使用高版本的`webpack`和`nodejs`

## http

* `http`常见状态码和含义

  > `200` 		请求没有问题，响应实体是请求的资源
  >
  > `201` 		创建服务器对象成功，响应头包含各种引用先创建对象的引用，	`Location`首部包含这个先创建对象的具体引用。服务器必须在发送这个状态码前创建好对象
  >
  > `204` 		响应报文中没有实体的主体部分
  >
  > `301` 		永久重定向
  >
  > `302`		 临时重定向
  >
  > `304` 		资源未被修改
  >
  > `400`		 错误的请求
  >
  > `401` 		请求未认证
  >
  > `403` 		请求被服务器拒绝
  >
  > `405` 		请求方法不支持
  >
  > `408`		 请求超时
  >
  > `409` 		请求可能在资源上引发一些冲突 比如新增已存在的数据
  >
  > `415` 		服务器无法理解客户端发出的实体的内容类型
  >
  > `500` 		服务器出错
  >
  > `504`  		网关超时

* `http2.0`有哪些新功能

  > 1. 多路复用
  >
  >    同一个TCP链接可以并发的发起多个请求，不受限制
  >
  > 2. 首部压缩
  >
  >    对`http`请求头进行压缩
  >
  > 3. 服务器推送
  >
  >    服务端主动推送消息到客户度
  >
  > 4. 二进制协议
  >
  
* `http/1.1`的长链接和`http/2`的多路复用有什么区别

  > `http/1.1`的长链接多个请求必须排队，会对头阻塞

* `GET` 和`POST`的区别

  > 在浏览器中`GET`会被缓存,`GET`请求的参数只能发在`url`上，而`POST`可以放在`BODY`体中。
  >
  > `GET`是幂等性,同一个`url`请求多次得到相同结果，`POST`是非幂等性,
  >
  > `get`请求是有长度限制的
  >
  > 

* `TCP`三次握手和四次挥手

  > 

* 缓存

  * ｀If-None-Math｀和`Etag`

    > 客户端第一次请求资源，服务器生成`Etag`放在响应头返回给客户端客户端缓存这个`Etag`，第二次请求客户端讲`Etag`的值放入请求头的`If-None-Match`发送给服务端，服务端拿到之后和服务器上的对比如果相同就讲`If-None-Match`设为`false`，返回`403`,客户端使用缓存。
    >
    > 如果不同，就返回`200`，将数据返回客户端，客户端使用返回的新数据。

  * `cache-control`

    > 可选的值有`max-age`、`no-store`、`no-cache`、`must-revalidate`、
    >
    > 1. `max-age` : 设置缓存时效， 单位为秒。计算时刻从响应报文被创建时刻开始计时
    >
    > `cache-control: max-age=5`，在有效期内直接使用，过期去服务器重新请求。
    >
    > 2. `no-store`: 不允许缓存
    > 3. `no-cache`： 可以缓存，使用前必须要去服务器校验是否过期，是否有最新版本。每一个请求都会发送
    > 4. `must-revalidate`：缓存不过期直接使用，过期就去服务器验证，是否可以使用过期的资源
    >
    > `cache-control`不仅服务器可以返回设置，客户端也可以发送。如果服务器响应的资源的`cache-control: max-age=1000`, 客户端发送`cache-control: max-age=0`或`cache-control:no-cache`，将不会使用缓存的数据。浏览器的强制刷新就是这样实现的。而浏览器的前进、后退、跳转是不会发送`cache-control`请求头，所以会检查缓存。

    

    

    

* `http`与`https`的区别

  > 1. `https`是在`http`的基础上添加了一层处理加密的模块，服务端和客户端的信息传输都会通过TLS进行加密。
  > 2. 协议不一样
  > 3. `http`的默认端口是`80`,`https`的默认端口是`443`

## TypeScript

* 元组和数组的区别
* 怎么理解`TypeScript`
* `Typescript`中`type`和`interface`的区别

## 算法

* 排序算法



## 版本控制管理

* `git`如何放弃当前`commit`
* `git rebase`的作用
* 

## 其他

* 性能优化

* 浏览器渲染页面过程

* 重绘和回流

* `cookie`有哪些属性

  > 1. name
  > 2. value
  > 3. domain
  > 4. httpOnly           不能通过`javascript`访问
  > 5. path
  > 6. expires
  > 7. size
  > 8. samesite
  > 9. secure                 只有在`https` 下才会发送
  > 10. priority

