# 面试题

## vue

* `Vue` 响应式原理

* `nextTick`实现原理

* `watch`和`computed`的区别的实现原理

* 为什么采用异步渲染

* `Vue`的`data`属性为什么是一个函数

* `Vue`声明周期

* 组件之间的通信

  > * 父子组件通信
  > * 兄弟组件通信
  > * 跨级组件通信

* `keep-alive`

* `proxy`相比`defineProperty`的优势

* 双向数据绑定实现原理



## javascript

* `JavaScript`闭包

  > 1. 什么是闭包
  >
  >    `JavaScript`闭包是指有权访问另一个函数作用域中的变量的函数。
  >
  > 2. 闭包的作用：
  >     1. 闭包可以读取函数内部声明的变量。
  >     2. 让函数内部变量的值始终保持在内存中。
  > 3. 闭包注意事项
  >    1. 闭包使得函数中的变量一直贮存在内存中，大量使用闭包，会导致网页性能问题。在IE中会导致内存泄漏。
  >
  > 

 

* `JavaScript`有几种继承方式

  > 1. 组合继承
  >
  >    在子类的构造函数中， 使用`call`或`apply` 调用父类的构造函数实现实例属性和方法的继承，然后， 实例化父类，将实例化对象赋值给 子类的`prototype`，同时需要修改子类`prototype`中的`constructor`为子类的构造函数。  实现原型属性和方法的继承。这种继承方式因为是直接将父类实例化的对象直接赋值给子类的`prototype`。 会导致子类的`prototype`中不仅有父类`prototype`中的属性或方法还会有父类实例化对象的示例属性或方法。
  >
  > 2. 使用`create`实现
  >
  >    `ES5`的`Object`对象提供一个`create`方法， 他在内部声明一个构造函数，将改构造函数的原型赋值为`create`方法的参数，最后实例化这个构造函数并返回。
  >
  >    **可以利用这个特性来实现继承， 实现原理和组合继承一样，但是他借用了一个中间的一个空构造函数，这个构造函数没有任何实例属性和方法，所以相对于组合继承不会出现有多余的实例属性或方法**
  >
  > 3. 使用`ES6` 的 `extends` 来实现

* `new`一个类的过程

  > 1. 创建一个空的`JavaScript` 对象`{}`
  > 2. 将创建的对象作为其调用上下文，使用`this`来引用这个对象
  > 3. 将创建的对象的 `__proto__`指向构造函数的`prototype`
  > 4. 如果构造函数返回的是一个对象就返回对象，否则返回`this`

* `this`的理解

  > `JavaScript`的`this`是在运行时基于函数的执行环境决定的。一般分为以下几种
  >
  > * 全局环境
  >
  >   全局环境`this`指向 全局对象，浏览器中 全局对象为`window`
  >
  > * 普通函数调
  >
  >   普通函数调用在非严格模式`this`和在全局环境中一样，在严格模式下 `this`为`undefined`
  >
  > * 构造函数
  >
  >   构造函数中的`this`将指向正在构造的新对象，即实例化后的对象
  >
  > * 箭头函数
  >
  >   如果箭头函数被非箭头函数包裹，则箭头函数中的`this`为外层非箭头函数的`this`
  >
  > * 使用`call`、`apply`、`bind`
  >
  >   使用`call`、`apply`、`bind`方式调用 `this`的值分为以下几种情况
  >
  >   * 如果是一个对象，`this`为这个对象， 
  >   * 如果传入的是 `null`或 `undefined`，`this`将指向`全局对象`
  >   * 如果传入的是一个原始值，会使用对应的构造函数将其转换为对象，`this`将指向这个对象

* 数组哪些方法会改变原数组

  > `push`、`shift`、`pop`、`unshift`、`splice`、`concat`、`sort`、`fill`

* 数组的`splice`和`slice`的区别

  > 1. `slice`是浅复制一个数组中的多个元素，以数组的形式返回，原数组不会被改变，新数组的元素取决于`slice`参数的设置, 
  >
  > ​	第一个参数代表开始位置，默认从0开始，如果是负数，则从数组的倒数第几个开始，如果大于数组的长度，则返回空数组。
  >
  > ​	第二个参数结束的索引位置，默认是到数组的末尾。但不包含这个索引对应的元素，如果是负数，则从数组的倒数第几个结束，不包含索引位置的元素。如果大于数组长度，则到数组的末尾
  >
  > 2. `splice`是删除、替换现有元素、添加新元素来修改数组，并且以数组的形式返回被删除的元素。原数组会被修改。
  >
  >    第一个参数代表操作开始的位置
  >
  >    第二个参数代表需要删除数组的个数
  >
  >    第三个到第N个参数代表需要添加的数组元素
  >
  > 

* `call`、`apply`、`bind`的区别

  > 这三个函数方法都是改变`this`指向的。
  >
  > 
  >
  > 区别:
  >
  > 1. 执行函数的`call`和`apply`方法后函数就会马上执行对应的函数,无返回值，`bind`是返回一个函数，需要执行这个返回的新函数才能执行对应的函数。
  > 2. `call`和`bind`传递参数是直接传递，`apply`传递参数是传入一个参数数组

* 作用域和作用域链

  > 作用域是变量和函数可访问的区域，分为全局作用域、函数作用域、块级作用域。
  >
  > `JavaScript`在进入一个新执行环境执行时，会创建一个当前执行环境中变量和函数可以访问的所有作用域的有序集合。这个集合就是作用域链。作用域链保证了这些变量和函数的在可访问的作用域中的有序访问。作用域链的最前端永远是当前执行环境， 

* 事件捕获和事件冒泡

  > 事件冒泡是有事件最具体的元素开始接受，逐级向上传播一直到`document`。事件捕获和事件冒泡相反，它是从`document`到事件具体元素。**执行顺序是先执行事件捕获然后执行事件冒泡**

* 事件委托

  > 当一个页面注册的事件越来越多，会导致页面性能问题， 每一个处理事件函数都是一个对象，都会占用内存。事件委托可以利用**事件冒泡**机制将事件绑定到`DOM`的**父级或祖先**上，减少事件绑定对象。

* 事件对象中 `target`和`currentTarget`

  > `target`是事件触发的元素，`currentTarget`事件绑定的元素

* 如何获取函数的实参和形参的个数

  > 使用函数的`length` 获取形参的个数， 使用`arguments`或`ES6`的`...`操作符获取实参个数

* 节流和防抖

  > 节流是在一个单位时间内。只能有一次触发事件的回调函数被执行， 如果事件被触发多次，只有一次生效。
  >
  > 防抖是在事件被触发n秒后执行函数，如果在n秒内被在次触发，则重新计时。

* 事件循环

  > 

* 跨域

  > 1. `jsonp`
  >
  >    由于`script`标签不受同源策略的限制，客户端可以动态添加一个`script`标签，将`src`指向服务器资源地址，`src`参数带上一个回调函数的名称，然后在全局中注册这个回调函数。服务端接受并处理这个请求，将处理后的数据当做这个回调函数的参数并返回， 浏览器接受到这个脚本的返回值就会执行这个回调函数。
  >
  >    缺点： 
  >
  >    1. 请求方法只能是`GET`
  >    2. 安全性问题,`JSONP`会从其他域下加载脚本执行，会有安全隐患。
  >    3. 缺乏错误处理机制，无法检测服务器出错的原因
  >
  > 2. 服务器反向代理
  >
  >    需要代理服务器设置
  >
  > 3. `CORS`
  >
  >    需要服务器设置响应的响应头信息
  >
  > 4. `document.domain`
  >
  >    缺点：
  >
  >    1. 主域名必须要一样
  >
  > 5. `postmessage`

* `promise`

  > 

* 简单请求和复杂请求

  > 

* 箭头函数和普通函数的区别

  > 1. 箭头函数没有`this`,`arguments`,`super`,`new.target`的绑定
  > 2. 箭头函数不能用作构造函数， 因为箭头函数内部没有`[[Construct]]`方法。
  > 3. 箭头函数没有原型， 因为箭头函数不能用作构造函数，所以没有构建原型的需求。
  > 4. 不可以改变`this`的绑定,如果箭头函数被外层非箭头函数包裹，`this`为外层函数的`this`，否则为全局对象
  > 5. 不支持`arguments`,如果箭头函数被外层非箭头函数包裹，`arguments`为外层函数的`arguments`，否则会报错找不到`arguments`，可以通过显示命名参数或使用不定参数形式访问
  > 6. 不支持重复的命名参数，普通函数在非严格模式是可以有的

* `for...of`和`for`以及`for...in`的区别

  > 1. `for...in`循环可以对对象或数组进行循环， 循环的每一项是对象的`key`, 数组中的`key`为数组索引，对象循环输出的`key`的顺序不可预测， 对对象原型链中可以枚举的属性也会遍历出来。如果不想输出原型链中的可枚举属性，可以使用`hasOwnProperty`方法进行判断。
  > 2. `for`循环可以对`数组`或**`类数组`** 
  > 3. `for...of` 可以遍历具有迭代器方法的任何对象

## css/less/sass

* `flex`布局
* `grid`布局
* `BFC`
* 层叠上下文
* 选择符优先级
* 盒模型
* `transition`和`animation`的区别
* 垂直水平居中实现方式
* `padding`和`margin` 的百分比是相对于什么的

## node/express

* 如何处理高并发

## mongodb

* 数据类型
* 如何优化海量数据中分页查找时性能问题
* 如何做索引
* 什么是分片和复制集
* 基于地理位置做搜索
* 聚合

## http

* `http`常见状态码和含义
* `http2.0`有哪些新功能
* `GET` 和`POST`的区别
* `TCP`三次握手和四次挥手
* 缓存

## TypeScript



## 算法

* 排序算法



## 版本控制管理

* `git`如何放弃当前`commit`

## 其他

* 性能优化
* 浏览器渲染页面过程