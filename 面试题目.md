# 面试题

## vue

* `mvvm`的理解

  > `mvvm` 是一种 数据驱动视图的设计模式，`model`是数据模型,` view`是视图ui，`model`和`view`是独立的，他们通过 `viewModel`来进行交互。
  > `viewModel`通过数据绑定为`view`提供`model`，当数据发生变化视图会自动更新。
  > `view `上的操作会通过 `viewmodel` 上的事件监听来更新数据

* `v-model`的实现原理

  > `v-model`在模板编译的时候首先会给`input`、`select`的`value`赋值为组件`data`中的某一个属性。如果元素是`select`会绑定`change`事件,如果元素是`input`会根据`input`的`type`属性给`input`绑定对应的事件，类型是`checkbox`、`radio`之类的会绑定`change`事件，其他类型的会绑定`input`事件，当事件触发的时候会将事件对象上`taget.value`值赋值给这个属性，从而达到数据双向绑定。

* 虚拟`dom`

  > 虚拟`dom`是描述`DOM`结构的`javascript`对象。虚拟`dom`可以维护程序的状态，跟踪上一次状态，通过比较状态决定是否渲染真实`dom`,从而可以最小化`dom`操作，提升渲染能力。

* `Vue` 响应式原理

  > `Vue`响应式原理的核心是`Observer`、`Dep`、`Watcher`
  >
  > `Observer`中利用`defineProperty`对`data`数据的每一个属性进行`set`/`get`劫持。如果是嵌套的对象，会深度 去遍历，如果属性的值是一个数组，会将这个数组上一些方法重写。在每一个属性中实例化一个`Dep`进行依赖收集`wathch`以及通知`watch`的更新。`vue`会将模板编译成`render`函数。在`mount`阶段执行`render`函数的时候触发属性`get`进行依赖收集。当数据改变触发`set`,调用`dep.notiry`通知观察当前`dep`的所有`watcher`进行视图更新。
  
* `nextTick`实现原理

  > `vue`更新`dom`是异步操作，数据改变组件不会立即渲染。`nextTick`可以访问到数据改变，浏览器渲染之后的最新`dom`。`nextTick`将需要执行的回调，`push`到`callbacks`数组，然后定义一个执行这个数组中所有回调的函数，利用`Promise`或`setTimeout`将这个函数放入微任务队列或宏任务队列中，使得这些回调在下一次事件循环中执行，从而获取到最新的`dom`。

* `watch`和`computed`的区别

  > `computed`是对一个被观察的值进行计算后返回的一个新值，只有被观察的值发生变化才会。他本身也是一个watcher, 他所依赖的属性会对他进进行收集，当他所依赖的属性改变时 会对这个`watcher` 的`dirty `属性设置为 `true`。在 下次取值的时候，不要用缓存里面的值 而是要重新计算
  >
  > `watch`是对属性进行监听，属性变化就会执行对应的处理函数

* 为什么采用异步渲染

  > 当一个响应式属性同步修改多次，每一次属性修改都会触发`watcher`，每一触发都会执行复杂的计算和`dom`操作。`vue`在观察到数据变化时，将开启一个队列，并且缓冲同一事件循环中所有数据的改变，如果同一个`watcher`被多次触发，只会被推入队列一次，然后在下一次事件循环中执行。

* `Vue`组件的`data`属性为什么是一个函数

  > 组件可能被用来创建多个实例，如果`data`是一个纯对象，多个实例将共享一个数据对象，某一个实例上的数据被修改，会影响到其他组件实例。如如果是一个函数， 每次创建实例都是返回一个全新的副本数据。

* `Vue`声明周期

  > 1. `beforeCreated`
  > 2. `created`
  > 3. `beforeMounted`
  > 4. `mounted`
  > 5. `beforeUpdate`
  > 6. `updated`
  > 7. `activated`( 被`keep-alive`缓存的组件被激活时)
  > 8. `deactivated`( 被`keep-alive`缓存的组件被停用时)
  > 9. `beforeDestroy`
  > 10. `destroyed`

* 组件之间的通信

  > * `props` /` $emit`
  >
  > * `ref `/ `$parent/$children`
  >
  >   `ref`如果在普通对象上使用，指向`DOM`,如果是子组件，则指向组件实例
  >
  >   `$parent` 访问父组件
  >
  >   `$children`访问子组件
  >
  > * `EventBus（$emit/$on）`
  >
  >   创建一个空的`Vue`实例,用来触发事件和监听事件
  >
  > * `provide`/`inject`
  >
  >   祖先组件通过`provide`提供一个对象，子孙组件通过`inject`注入对象上的属性
  >
  > * `vuex`

* `keep-alive`

  > `keep-alive`是一个`vue`的内置的抽象组件，自身不会渲染一个DOM元素，也不会出现在父组件链中，使用`keep-alive`包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
  >
  > `keep-alive`首先获取包裹的第一个子组件对象和组件名称，根据设置的黑白名单判断是否缓存，根据组件`ID`和`tag`生成缓存的`key`,在缓存对象中查找是否缓存过改组件，如果有就取出缓存实例，并更新该`key`在`this.keys`中的位置,便于当缓存组件超出设置的最大缓存数量时处理。 否则将该组件缓存到缓存对象中，然后检查缓存数量是否超过缓存数量最大值，如果超过就删除最早缓存且未使用的组件，最后将组件实例的`keepAlive`属性设为`true`，用于被包裹组件的不会进入`mounted`和他之前的所有钩子函数。

* `proxy`相比`defineProperty`的优势

* `vue`性能优化

  > 1. 路由懒加载
  > 2. `keep-alive` 缓存
  > 3. 根据场景使用`v-show`复用`dom`
  > 4. 对纯展示数据，不会发生变化的数据可以设置数据费响应式
  > 5. 对大数据列表，使用虚拟滚动，
  > 6. 插件按需加载

  

* `key`的作用以及为什么不能使用`index`作为`key`

  > `key`的作用是在`vue`的虚拟DOM算法，在新旧`vnode`时辨识`vnode`,如果不使用`key`,`vue`会最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型的元素。使用了`key`,他会基于`key`的变化重新排列元素的顺序，并移除`key`不存在的元素。还可以强制替换组件或元素， 而不是复用他们。
  >
  > 
  >
  > 如果使用`index`作为`key`,当向数据列表中间或头部插入数据的时候，会导致插入数据位置之后的`key`发生了改变，根据`diff`算法比较两个`vnode`的`key`不一样了，在`patch`的时候回删除这些`dom`重新创建添加。

* `diff`算法

  > 过程如下：
  >
  > 1. 同级比较，在比较子节点，如果元素类型不一样就直接删除，重新创建。
  >
  > 2. 判断一方有子节点，一方没有子节点
  >
  >    1. 新的有子节点，旧的没有，就新建节点
  >    2. 旧的有子节点，新的没有，就删除旧子节点
  >
  > 3. 双方都有子节点
  >
  >    1. 新旧的头对比，如果一样直接复用，头指针向后移动，
  >    2. 如果不一样，新旧的尾对比，一样直接复用，指针向前走，
  >    3. 如果不一样，旧头和新尾比，如果一样，将旧头移动到旧节点列表中新尾指针的位置，旧头指针向后移动，新尾指针向前移动
  >    4. 如果不一样，新头和旧尾比，如果一样，将旧尾移动到旧节点列表中新头指针的位置，新头指针向后移动，旧尾指针向前移动。
  >    5. 如果不一样，判断对比的新节点是否有`key`，如果有`key`,根据`key`从老节点列表中查找对应的节点,如果存在。将旧节点插入到这个旧节点列表中索引为新节点列表中在新节点的索引的位置。如果没有就创建新节点。
  >
  > 4. 递归比较子节点
  >   
  >
  >  

## javascript

* 垃圾回收中的堆和栈的区别

* `V8`垃圾回收机制

  > `v8`的垃圾回收机制采用了分代式垃圾回收机制。将堆内存分为`新生代`和`老生代`。
  >
  > `新生代`中存储的一般是存活时间较短的对象。`新生代`中采用 Scavenge 垃圾回收算法，将内存分为两块区域`from`和`to`。新分配的对象首先进入`from`。当`from`空间满的时候，会启动垃圾回收。将`from`中存活的对象复制到`to`中，销毁失活的对象，清空`from`中的全部内存。最后将`from`空间和`to`空间互换。等待下一次垃圾回收。当对象从`from`空间复制到`to`空间的时候，检测对象是否经历过一次垃圾回收的过程，如果经历过或者`to`空间占用新生代内存的`25%`就会将这个对象直接从`from`空间移动到`老生代`内存中。
  >
  > `老生代`采用标记整理和标记清除结合来进行垃圾回收，首先进入标记阶段会遍历内存中的所有对象，对活着的对象进行标记，然后进入整理阶段，将所有存活的对象向内存空间的一侧移动，进入清除阶段，将边界的另一侧内存一次性全部回收。
  
* `==`操作符比较

  > 1. 比较双方两边都是`undefined | null`或者一边为`null`,一边为`undefined` 或者 一边为`+0`,一边为`-0`都返回`true`
  > 2. 比较双方是一方`NaN`返回`false`
  > 3. 两方是相同的普通数据类型 完全一样返回`true`，引用类型引用统一对象返回`true`。
  > 4. 一方数据类型为引用类型,先转成普通类型在对比
  > 5. 两方是不通的普通数据类型，转换成`number`进行对比。

* `===`和`Object.is`比较的区别

  > `===` 判断`NaN`和`NaN`是不等的, ` +0`和`-0`是相等的
  >
  > `Object.is`判断`NaN`和`NaN`是相等的, ` +0`和`-0`是不等的
  
* `javaScript`有哪些数据类型，如何判断

  > 数据类型：`String`、`Number`、`Boolean`、`Function`、`Object`、`Symbol`、`Undefined`
  >
  > 判断： `typeof`、`instanceof`、`Object.prototype.toString.call`、`方法判断`
  >
  > ```javascript
  > var str = '111'
  > 
  > typeof str === 'string'		// 不能判断 new String(1)
  > String(str) === str				// 不能判断 new String(1)
  > str instanceof String			// 不能判断基本数据类型的 string
  > Object.prototype.toString.call(str) === '[object String]'	// 对基本类型字符串和对象类型字符串都可以
  > str.indexOf === String.prototype.indexOf	// 对基本类型字符串和对象类型字符串都可以
  > 
  > ```
  >
  > 
  
* `var`、`let`、`const`的区别

  > *  var
  >
  >    *  有变量提升特效
  >   *  只有全局作用域和函数作用域，无块级作用域
  >    *  可重复定义与赋值
  >    *  在给一个非声明变量赋值会隐式创建一个全局变量
  >    *  浏览器环境下，全局作用域下的变量与window下同名属性全等的
  > 
  > *  let
  >
  >    *  只在其声明的代码块或子块中有效
  >   *  存在暂时性死区（将变量提升到语句块顶部，但在块的开始到声明这一段使用这个变量会导致错误，这一段称之为暂存死区）
  >    *  不允许在相同作用域内重复声明，也不能对参数重新声明
  >    *  在全局中声明的变量与window属性不等
  > 
  > * const
  >
  >   **有上面let的特性和下面的两个自己的特性**
  >
  >   * 常量的值不能改变 (不能改变的是内存地址，复合型数据类型是可以改变的)
  >  * 常量必须在声明的时候就赋值
  
* `JavaScript`闭包

  > 1. 什么是闭包
  >
  >    `JavaScript`闭包是指有权访问另一个函数作用域中的变量的函数。
  >
  > 2. 闭包的作用：
  >     1. 闭包可以读取函数内部声明的变量。
  >     2. 让函数内部变量的值始终保持在内存中。因为内部的变量存在堆内存中
  > 3. 闭包注意事项
  >   
  >    1. 闭包使得函数中的变量一直贮存在内存中，大量使用闭包，会导致网页性能问题。在IE中会导致内存泄漏。
  >
  > 

 

* `JavaScript`有几种继承方式

  > 1. 组合继承
  >
  >    在子类的构造函数中， 使用`call`或`apply` 调用父类的构造函数实现实例属性和方法的继承，然后， 实例化父类，将实例化对象赋值给 子类的`prototype`，同时需要修改子类`prototype`中的`constructor`为子类的构造函数。  实现原型属性和方法的继承。这种继承方式因为是直接将父类实例化的对象直接赋值给子类的`prototype`。 会导致子类的`prototype`中不仅有父类`prototype`中的属性或方法还会有父类实例化对象的示例属性或方法。
  >
  > 2. 使用`create`实现
  >
  >    `ES5`的`Object`对象提供一个`create`方法， 他在内部声明一个构造函数，将改构造函数的原型赋值为`create`方法的参数，最后实例化这个构造函数并返回。
  >
  >    **可以利用这个特性来实现继承， 实现原理和组合继承一样，但是他借用了一个中间的一个空构造函数，这个构造函数没有任何实例属性和方法，所以相对于组合继承不会出现有多余的实例属性或方法**
  >
  > 3. 使用`ES6` 的 `extends` 来实现

* `new`一个类的过程

  > 1. 创建一个空的`JavaScript` 对象`{}`
  > 2. 绑定`this`,执行构造函数
  > 3. 链接到原型，将创建的对象的 `__proto__`指向构造函数的`prototype`
  > 4. 如果构造函数返回的是一个对象就返回对象，否则返回`this`

* `this`的理解

  > `JavaScript`的`this`是在运行时基于函数的执行环境决定的。一般分为以下几种
  >
  > * 全局环境
  >
  >   全局环境`this`指向 全局对象，浏览器中 全局对象为`window`
  >
  > * 普通函数调
  >
  >   普通函数调用在非严格模式`this`和在全局环境中一样，在严格模式下 `this`为`undefined`
  >
  > * 构造函数
  >
  >   构造函数中的`this`将指向正在构造的新对象，即实例化后的对象
  >
  > * 箭头函数
  >
  >   如果箭头函数被非箭头函数包裹，则箭头函数中的`this`为外层非箭头函数的`this`
  >
  > * 使用`call`、`apply`、`bind`
  >
  >   使用`call`、`apply`、`bind`方式调用 `this`的值分为以下几种情况
  >
  >   * 如果是一个对象，`this`为这个对象， 
  >   * 如果传入的是 `null`或 `undefined`，`this`将指向`全局对象`
  >   * 如果传入的是一个原始值，会使用对应的构造函数将其转换为对象，`this`将指向这个对象

* 数组哪些方法会改变原数组

  > `push`、`shift`、`pop`、`unshift`、`splice`、`concat`、`sort`、`fill`

* 数组的`splice`和`slice`的区别

  > 1. `slice`是浅复制一个数组中的多个元素，以数组的形式返回，原数组不会被改变，新数组的元素取决于`slice`参数的设置, 
  >
  > ​	第一个参数代表开始位置，默认从0开始，如果是负数，则从数组的倒数第几个开始，如果大于数组的长度，则返回空数组。
  >
  > ​	第二个参数结束的索引位置，默认是到数组的末尾。但不包含这个索引对应的元素，如果是负数，则从数组的倒数第几个结束，不包含索引位置的元素。如果大于数组长度，则到数组的末尾
  >
  > 2. `splice`是删除、替换现有元素、添加新元素来修改数组，并且以数组的形式返回被删除的元素。原数组会被修改。
  >
  >    第一个参数代表操作开始的位置
  >
  >    第二个参数代表需要删除数组的个数
  >
  >    第三个到第N个参数代表需要添加的数组元素
  >
  > 

* `call`、`apply`、`bind`的区别

  > 这三个函数方法都是改变`this`指向的。
  >
  > 
  >
  > 区别:
  >
  > 1. 执行函数的`call`和`apply`方法后函数就会马上执行对应的函数,无返回值，`bind`是返回一个函数，需要执行这个返回的新函数才能执行对应的函数。
  > 2. `call`和`bind`传递参数是直接传递，`apply`传递参数是传入一个参数数组

* 作用域和作用域链

  > 作用域是变量和函数可访问的区域，分为全局作用域、函数作用域、块级作用域。
  >
  > `JavaScript`在进入一个新执行环境执行时，会创建一个当前执行环境中变量和函数可以访问的所有作用域的有序集合。这个集合就是作用域链。作用域链保证了这些变量和函数的在可访问的作用域中的有序访问。作用域链的最前端永远是当前执行环境， 

* 事件捕获和事件冒泡

  > 事件冒泡是有事件最具体的元素开始接受，逐级向上传播一直到`document`。事件捕获和事件冒泡相反，它是从`document`到事件具体元素。**执行顺序是先执行事件捕获然后执行事件冒泡**

* 事件委托

  > 当一个页面注册的事件越来越多，会导致页面性能问题， 每一个处理事件函数都是一个对象，都会占用内存。事件委托可以利用**事件冒泡**机制将事件绑定到`DOM`的**父级或祖先**上，减少事件绑定对象。
  >
  > 如果我们判断的元素里面还有子元素的时候，我们点击的时候子元素，这时候`target`是子元素。这样就不会执行事件处理函数。需要使用下面的方式可以达到效果
  >
  > ```js
  > function delegate(element, eventType, selector, fn) {
  >   element.addEventListener(eventType, e => {
  >     let el = e.path.find(el => el.matches(selector))
  >     el && fn.call(el, e, el)
  >   })
  >   return element
  > }
  > ```
  >
  > 

* 事件对象中 `target`和`currentTarget`

  > `target`是事件触发的元素，`currentTarget`事件绑定的元素

* 如何获取函数的实参和形参的个数

  > 使用函数的`length` 获取形参的个数， 使用`arguments`或`ES6`的`...`操作符获取实参个数

* 节流和防抖

  > 节流是在一个单位时间内。如果事件被触发多次，只有一次生效。
  >
  > 防抖是在事件被触发n秒后执行函数，如果在n秒内被在次触发，则重新计时。

* 浏览器事件循环

* ？什么是单线程

* ？宏任务交给了什么线程执行

* ？`promise` 中的`then`回调是什么时候插入到微任务队列的

* ？`script`中的代码会被插入到宏任务队列中吗

* ？页面的渲染是在什么时候执行的

  > 在`js`中有`宏任务`和`微任务`。`script`和`setTimeout`、`fetch`等属于宏任务。`promise`、`process.nextTick`等属于微任务。
  >
  > 1. 脚本被当做宏任务首先执行
  >
  > 2. 执行过程中，同步代码直接执行，宏任务会交由浏览器其他线程处理，当其他线程处理完毕后会将对应的回调放入宏任务队列中。对于微任务，会将微任务对应的回调保存，在微任务处理完毕后将这些回调放入微任务队列中。
  >
  > 3. 当前宏任务执行完毕，首先会依次执行微任务队列中的回调。
  >
  > 4. 执行完微任务队列中的所有回调后。执行浏览器渲染。完成本次事件循环，然后到宏任务队列中执行对应的回调开始下一轮循环。
  >
  >    

* 跨域

  > 1. `jsonp`
  >
  >    由于`script`标签不受同源策略的限制，客户端可以动态添加一个`script`标签，将`src`指向服务器资源地址，`src`参数带上一个回调函数的名称，然后在全局中注册这个回调函数。服务端接受并处理这个请求，将处理后的数据当做这个回调函数的参数并返回， 浏览器接受到这个脚本的返回值就会执行这个回调函数。
  >
  >    缺点： 
  >
  >    1. 请求方法只能是`GET`
  >    2. 安全性问题,`JSONP`会从其他域下加载脚本执行，会有安全隐患。
  >    3. 缺乏错误处理机制，无法检测服务器出错的原因
  >
  > 2. 服务器反向代理
  >
  >    需要代理服务器设置
  >
  > 3. `CORS`
  >
  >    需要服务器设置响应的响应头信息
  >
  > 4. `document.domain`
  >
  >    缺点：
  >
  >    1. 主域名必须要一样
  >
  > 5. `postmessage`

* `promise`

  > * Promise 中 .then 的第二参数与 .catch 有什么区别?
  >
  >   
  >
  > * 
  >
  > 

* 简单请求和复杂请求

* `commonjs`和`es module`的区别

  > 1. `commonjs`是动态引入，在运行时引入。`es module`是静态引入，在编译时引入。
  > 2. `commonjs`输出的是值的浅拷贝。`es module`输出的是值的引用
  > 3. `commonjs`具有缓存，在第一次被加载后，会贮存在内存中，后面的导入会直接从内存中读取

* 箭头函数和普通函数的区别

  > 1. 箭头函数没有`this`,`arguments`,`super`,`new.target`的绑定
  > 2. 箭头函数不能用作构造函数， 因为箭头函数内部没有`[[Construct]]`方法。
  > 3. 箭头函数没有原型， 因为箭头函数不能用作构造函数，所以没有构建原型的需求。
  > 4. 不可以改变`this`的绑定,如果箭头函数被外层非箭头函数包裹，`this`为外层函数的`this`，否则为全局对象
  > 5. 不支持`arguments`,如果箭头函数被外层非箭头函数包裹，`arguments`为外层函数的`arguments`，否则会报错找不到`arguments`，可以通过显示命名参数或使用不定参数形式访问
  > 6. 不支持重复的命名参数，普通函数在非严格模式是可以有的

* `for...of`和`for`以及`for...in`的区别

  > 1. `for...in`循环可以对对象或数组进行循环， 循环的每一项是对象的`key`, 数组中的`key`为数组索引，对象循环输出的`key`的顺序不可预测， 对对象原型链中可以枚举的属性也会遍历出来。如果不想输出原型链中的可枚举属性，可以使用`hasOwnProperty`方法进行判断。
  > 2. `for`循环可以对`数组`或**`类数组`** 
  > 3. `for...of` 可以遍历具有迭代器方法的任何对象

* 0.1 + 0.2 = 0.3 怎么处理

* `hash`路由和`history`路由的区别

  > 1. `hash`路由路由中会有`#`， 是根据路由中的`hash`片段的改变来导航，监听`hashchange`事件。`history`是`h5`提供的`api`来实现的。主要是`pushState`和`replaceState`来实现。
  > 2. `history`事件可以使用`replaceState`将访问历史记录替换。
  > 3. `history`模式需要在服务器中设置

* 实现深拷贝

  > 1. 递归遍历实现，实现过程检测类型，还需要检测是否有循环引用，如果使用`for in`还需要注意是否是原型上的属性
  > 2. 使用`JSON.stringify`和`JSOfN.parse`，这种方式对数据格式有要求，值不能为 `undefined`、`function`类型

* 引用数据类型转原始数据类型转换过程

  > 引用数据类型转原始数据类型过程会调用内置的`to Primitive`方法，该方法首先会调用对象的`valueOf` 方法，结果如果是原始值就直接返回。否则会调用`toString`方法。结果如果是原始值就直接返回。否则报错。我们可以重写`toPrimitive`、`valueOf`、`toString`来改变转换结果。`toPrimitive`的优先级最高。
  >
  > ```js
  > const obj = {
  >   valueOf(){
  >     return 1
  >   },
  >   
  >   toString(){
  >     return '2'
  >   },
  >   
  >   [Symbol.toPrimitive](){
  >     return 3
  >   }
  > }
  > ```
  >
  > 

## css/less/sass

* `flex`布局

* `grid`布局

* `BFC`

  > `BFC`是块级格式化上下文。指当元素满足特定条件就会形成一个**单独**盒模型渲染模式的区域。与其他区域互不影响。
  >
  > 触发`BFC`的条件：根元素、`position`值不为`static`和`relative`、`float`不为`none`、`overflow`不为`visible`、`display`值为`flex`、`table-cell`、`table-caption`、`inline-block`、`inline-flex`、` flow-root`、 `grid`等
  >
  > `BFC`特点：
  >
  > 1. 一个独立的渲染区域，与外部互不影响
  > 2. 内部元素按垂直方向从上向下排列
  > 3. `margin`不会叠加

* 层叠上下文

* 选择符优先级

  > `!import > 内联 style > id > class 、属性选择器 > 标签 > *`

* 盒模型

  > 正常模式：宽度 = padding + border + content
  >
  > 怪异模式：宽度 = content 宽度
  >
  > 怎么触发怪异模式计算：`CSS3`的`box-sizing: border-box`,`doctype`的缺失在IE6,7,8中会触发怪异模式。

* `transition`和`animation`的区别

  > `transition`是在两个状态之间的过渡，`animation`可以更细粒的控制，还可以循环播放。

* 垂直水平居中实现方式

  > 1. `flex`布局
  > 2. `grid`
  > 3. `aboute`
  > 4. `line-height`和`marign: 0 auto`
  > 5. `table`

* `position`有哪些属性

  > 1. `relative`
  > 2. `absoute`
  > 3. `sticky`
  > 4. `static`
  > 5. `fixed`

* `padding`和`margin` 的百分比是相对于什么的

  > `padding`和`margin`的百分比是相对于元素自身的宽度。



* `margin`和`padding`在`block`和`inline`中的区别

  > `block`的`padding`和`margin`设置后都会产生边距。
  >
  > `inline`的`padding`和`margin`的`left`和`right`会产生边距，`top`和`bottom`不会产生边距

* `flex: 0 1 auto`是什么意思

  > `flex`是`flex-grow`、`flex-shrink`、`flex-basis`的简写
  >
  > `flex-grow`为项目的放大比例 .`0`为如果存在剩余空间，也不放大。
  >
  > `flex-shrink`为定义了项目的缩小比例。`1`如果空间不足，该项目将缩小 
  >
  > `flex-basis`为属性定义了在分配多余空间之前，项目占据的主轴空间（main size）`auto`为`item`原来的大小

## node/express

* 如何处理高并发

## mongodb

* 如何优化海量数据中分页查找时性能问题

  > 客户端发送一个有序、唯一、可以比较的一个字段，这个字段的值是每一次分页返回的最后一条数据的字段值。通过这个字段减少分页的搜索数据量。

* 如何做索引

* 什么是分片和复制集

  > 分片是将数据拆分，将其分散存在到不同的机子上。分片可以存储更多的数据，处理更大的负载。
  >
  > 复制集是自动故障恢复的主从集群。主节点负责写入数据，从节点自动同步主节点的数据，并提供查询

* 基于地理位置做搜索

* 聚合

## webpack

* `Webpack`原理，以及常用插件

* `scope hosting`

  > `webpack`打包后生成的是一个立即执行函数，参数是一个数组，数组每一项是包装各个模块的`js`代码的闭包函数。使用`scope hosting`会尽可能将那些模块函数合并到一个函数中，减少文件大小，以及内存占用。

* `loader`

  > `webpack`把所有资源当成模块处理，这些资源最终需要转换成不同类型的资源。`loader`本质上就是一个函数，对这些模块对这些模块进行转换，最后返回转换后的结果。如：`TypeScript`转换成`JavaScript`,`less`转换成`css`等.

* `plugin`

  > `plugin`用于解决`loader`无法实现的其他事，`plugin`可以扩展`webpack`的功能。可以监听在`webpack`运行的声明周期中发出的各种事件，然后通过`webpack`提供的`api`改变输出结果。

* `webpack`构建流程

  > 1. 合并配置文件和 shell 中的配置参数
  > 2. 根据这些参数



* `webpack`构建速度优化

  > `webpack`优化首先需要分析是哪一块比较耗时，可以使用`speed-measure-webpack-plugin`插件，来分析整个打包过程的总耗时和每一个插件和`loader`的耗时。
  >
  > 解决方案：
  >
  > 1. 使用高版本的`webpack`和`nodejs`
  > 2. 对`babel-loader`配置缓存，以及指定处理文件，减少处理文件的数量
  > 3. 使用`happyloader`进行多进程编译
  > 4. 使用多进程压缩插件进行多进程压缩

* `webpack`优化产出代码

  > 1. 对小图片base64或使用`css sprite`
  > 2. 懒加载模块
  > 3. 提取公共代码
  > 4. 使用`ingorePlugin`忽略一些没用的代码，如一些语言包
  > 5. 使用`cdn`加速
  > 6. 指定生产模式
  >    1. 自动开启压缩
  >    2. 一些框架会自动删除调试代码
  >    3. 自动开启tree-shanking

## http

* `http`常见状态码和含义

  > `200` 		请求没有问题，响应实体是请求的资源
  >
  > `201` 		创建服务器对象成功，响应头包含各种引用先创建对象的引用，	`Location`首部包含这个先创建对象的具体引用。服务器必须在发送这个状态码前创建好对象
  >
  > `204` 		响应报文中没有实体的主体部分
  >
  > `301` 		永久重定向
  >
  > `302`		 临时重定向
  >
  > `304` 		资源未被修改
  >
  > `400`		 错误的请求
  >
  > `401` 		请求未认证
  >
  > `403` 		请求被服务器拒绝
  >
  > `405` 		请求方法不支持
  >
  > `408`		 请求超时
  >
  > `409` 		请求可能在资源上引发一些冲突 比如新增已存在的数据
  >
  > `415` 		服务器无法理解客户端发出的实体的内容类型
  >
  > `500` 		服务器出错
  >
  > `504`  		网关超时

* `http2.0`有哪些新功能

  > 1. 多路复用
  >
  >    同一个TCP链接可以并发的发起多个请求，不受限制
  >
  > 2. 首部压缩
  >
  >    对`http`请求头进行压缩
  >
  > 3. 服务器推送
  >
  >    服务端主动推送消息到客户度
  >
  > 4. 二进制协议
  >
  > 
  
* `http/1.1`的长链接和`http/2`的多路复用有什么区别

  > `http/1.1`的长链接多个请求必须排队，会对头阻塞。长链接只是在指定时间内不会关闭 `TCP` 链接, 但是还是会对请求个数有限制， 每一个`TCP`链接只能同时有`6`个请求, 只有在少于`6`个请求工作的时候，才会发起下一个请求。多路复用是在一个`TCP`下可以同时发起任意个`http`请求，

* `GET` 和`POST`的区别

  > 在浏览器中`GET`会被缓存,`GET`请求的参数只能发在`url`上，而`POST`可以放在`BODY`体中。
  >
  > `GET`是幂等性,同一个`url`请求多次得到相同结果，`POST`是非幂等性,
  >
  > `get`请求是有长度限制的
  >
  > 

* `TCP`三次握手和四次挥手

  > 三次握手是为了建立一个可靠`tcp`的链接
  >
  > 第一次：客户端发送位码`syn=1`,随机产生`seq`序列号的数据包到服务端
  >
  > 第二次：服务端收到后确认联机信息，向客户端发送`ack number`，`syn=1`,`ack=1`以及随机产生`seq`序列号的数据包给客户端
  >
  > 第三次： 客户端收到后检查`ack number`是否正确，以及`ack`是否为1.如果正确，将会发送`ack number`，`ack=1`到服务端，服务端收到请求后确认`ack`是否正确以及`syn=1`,如果正确则简历链接成功。
  >
  > 四次挥手
  >
  > 第一次： 客户端发送关闭请求
  >
  > 第二次： 服务端回应客户端收到了关闭请求，但还没有准备好关闭链接
  >
  > 第三次：服务端准备好关闭链接，向客户端发送关闭链接请求
  >
  > 第四次：客户端收到关闭链接请求，发送一个确认包，服务端确认后关闭链接

  

* 缓存

  * `If-None-Math`和`Etag` 、`If-Modified-Since`和`Last-modified`

    > 客户端第一次请求资源，服务器生成`Etag`放在响应头返回给客户端客户端缓存这个`Etag`，第二次请求客户端将`Etag`的值放入请求头的``If-None-Match`发送给服务端，服务端拿到之后和服务器上的对比如果相同就将`If-None-Match`设为`false`，返回`403`,客户端使用缓存。
    >
    > 如果不同，就返回`200`，将数据返回客户端，客户端使用返回的新数据。
    >
    > `If-Modified-Since`和`Last-modified`发送的是文件最后修改时间。不管文件和之前的是否一样，只要是修改过或者只是添加或删除对程序本身运行没有响应的字符，就认为需要重新发送给客户端

  * `cache-control`

    > 可选的值有`max-age`、`no-store`、`no-cache`、`must-revalidate`、
    >
    > 1. `max-age` : 设置缓存时效， 单位为秒。计算时刻从响应报文被创建时刻开始计时
    >
    > `cache-control: max-age=5`，在有效期内直接使用，过期去服务器重新请求。
    >
    > 2. `no-store`: 不允许缓存
    > 3. `no-cache`： 可以缓存，使用前必须要去服务器校验是否过期，是否有最新版本。每一个请求都会发送
    > 4. `must-revalidate`：缓存不过期直接使用，过期就去服务器验证，是否可以使用过期的资源
    >
    > `cache-control`不仅服务器可以返回设置，客户端也可以发送。如果服务器响应的资源的`cache-control: max-age=1000`, 客户端发送`cache-control: max-age=0`或`cache-control:no-cache`，将不会使用缓存的数据。浏览器的强制刷新就是这样实现的。而浏览器的前进、后退、跳转是不会发送`cache-control`请求头，所以会检查缓存。

    

* `http`与`https`的区别

  > 1. `https`是在`http`的基础上添加了一层处理加密的模块，服务端和客户端的信息传输都会通过TLS进行加密。
  > 2. 协议不一样
  > 3. `http`的默认端口是`80`,`https`的默认端口是`443`

* 性能优化

> 前端性能优化可以从网络请求、资源文件、缓存等方面进行分析优化，可以使用`window.performance`中拿到每一个阶段的用时来进行性能分析。在网络请求中可以做`DNS预解析`、`资源预加载`、`资源预解析`、`使用http2`、`使用域名分片`、`合并压缩资源减少请求数`、``、``、``

* `https`握手过程

  > 1. 客户端发送`clinet hello`产生一个随机数和客户端支持的加密套件列表给服务端
  > 2. 服务端接收客户端的`clinet hello`产生一个随机数并选择一个客户端支持加密套件
  > 3. 服务端继续返回一个证书给客户端

## TypeScript

* 元组和数组的区别

  > 数组的长度不固定，元组类型的值长度是定义时的长度
  >
  > 数组中每一个值的类型只要符合定义时的类型即可，没有顺序限制，元组中值的类型是定义时的顺序.但是可以通过元组变量的方法添加删除元素,以及修改元素的类型, 但是不能访问

* 怎么理解`TypeScript`

  > `TypeScript`是`JavaScript`的超集，支持所有版本的`JavaScript`语法。并提供了`静态类型系统`和 `ES`的最新语法的支持。浏览器本身不支持`TypeScript`，最终还是需要通过工具编译成`JavaScript`。`TypeScript`可以在编译阶段就能发现一些潜在的错误

* `Typescript`中`type`和`interface`的区别

  > 1. `type`可以声明基本类型别名，如联合类型，元组等。 `interfalce`不可以。
  >
  > 2. `type`可以使用`typeof`获取实例的类型进行赋值
  > 3. `interface`可以声明合并，多个相同名称的`interface`会合并为一个

## 算法

* 排序算法



## 版本控制管理

* `git`放弃当前 `add`

  > ```bash
  > # 撤销所有 add
  > $ git reset HEAD .
  > 
  > # 撤销 指定文件或文件夹
  > $ git reset HEAD -filename
  > ```
  >
  > 

* `git`如何放弃当前`commit`

  > 

* `git rebase`的作用

* 

## 其他

* 性能优化

* `CSRF` 跨站请求伪造和`XSS` 跨站脚本攻击是什么？

* 进程和线程

  > 进程是一个程序运行的实例。执行一个程序，会为这个程序分配一块内存空间，用来存放代码，运行中的数据和一个执行任务的主线程。

* 浏览器渲染页面过程

  > 当输入域名访问一个网站的时候，浏览器首先进行`dns`解析，将域名解析为对应的`IP`地址，然后建立`TCP`链接。链接建立成功后，发起第一个`http`请求，请求`index`页面完成后，解析`index.html`,构建`DOM`树，请求`css`，`js`资源。请求`css`资源会阻塞页面的渲染，请求`js`会阻塞`dom`的构建。`css`请求完成，解析`css`构建`cssom`树。然后将`dom`树和`cssom`树合并生成渲染树，遍历渲染树，计算每一个节点的位置大小信息，将节点绘制到屏幕。
  >
  > 1. 浏览器`dns`缓存查找
  > 2. 系统`host`中查找
  > 3. 路由器缓存中查找
  > 4. ISP（互联网服务提供商 ）缓存
  > 5. 根域名服务器
  > 6. 顶级域名服务器
  > 7. 主域名服务器

* 重绘和回流

  > `HTML`默认是流式布局当节点的位置大小改变，触发回流，回流会导致页面重新执行渲染过程。
  >
  > 当节点的颜色透明度改变，这种节点的位置大小的没有改动会触发重绘 ，重绘不会改变整体布局。
  >
  > 回流必然会导致重绘。

* `cookie`有哪些属性

  > 1. name
  > 2. value
  > 3. domain
  > 4. httpOnly           不能通过`javascript`访问
  > 5. path
  > 6. expires
  > 7. size
  > 8. samesite
  > 9. secure                 只有在`https` 下才会发送
  > 10. priority

* 为什么要用打包和构建

  1. 代码层方面
     * 打包构建后文件体积变小和文件数量减少，提供加载性能
     * 编译高级语言或语法
     * 在打包构建时可以屏蔽一些兼容性以及对一些错误可以在打包过程中发现
  2. 工程化方面
     * 统一的构建流程和标准
     * 统一、高效的开发环境
     * 集成公司的规范

* `loader` 和 `plugin`

  > `loader`是一个转义器， 用于对模块的源代码进行转换。默认`webpack`只支持`js`和`json`类型的文件，对于其他类型的文件，需要使用`loader`将其转换成有效的模块， 并添加到依赖树中。`webpack loader`采用了函数的`compose`的函数组合方式来执行的。多个	`loader`	的执行是从后往前串行执行的。`loader`本质上就是一个函数，模块的源代码作为参数，在函数内部通过对应处理后，返回处理后的结果。`loader`分为`同步`和`异步`.